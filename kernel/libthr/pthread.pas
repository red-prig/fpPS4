unit pthread;

{$mode ObjFPC}{$H+}
{$CALLING SysV_ABI_CDecl}

interface

uses
 signal;

const
 PTHREAD_DESTRUCTOR_ITERATIONS=4;
 PTHREAD_KEYS_MAX             =256;
 PTHREAD_STACK_MIN            =MINSIGSTKSZ;
 PTHREAD_THREADS_MAX          =High(QWORD);
 PTHREAD_BARRIER_SERIAL_THREAD=-1;

 PTHREAD_DETACHED     =$1;
 PTHREAD_SCOPE_SYSTEM =$2;
 PTHREAD_INHERIT_SCHED=$4;
 PTHREAD_NOFLOAT      =$8;

 PTHREAD_CREATE_DETACHED=PTHREAD_DETACHED;
 PTHREAD_CREATE_JOINABLE=0;
 PTHREAD_SCOPE_PROCESS  =0;
 PTHREAD_EXPLICIT_SCHED =0;

 PTHREAD_PROCESS_PRIVATE=0;
 PTHREAD_PROCESS_SHARED =1;

 PTHREAD_CANCEL_ENABLE      =0;
 PTHREAD_CANCEL_DISABLE     =1;
 PTHREAD_CANCEL_DEFERRED    =0;
 PTHREAD_CANCEL_ASYNCHRONOUS=2;
 PTHREAD_CANCELED           =Pointer(1);

 PTHREAD_NEEDS_INIT=0;
 PTHREAD_DONE_INIT =1;

 //PTHREAD_ONCE_INIT { PTHREAD_NEEDS_INIT, NULL }

 PTHREAD_MUTEX_INITIALIZER            =nil;
 PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP=Pointer(1);
 PTHREAD_COND_INITIALIZER             =nil;
 PTHREAD_RWLOCK_INITIALIZER           =nil;

 PTHREAD_PRIO_NONE   =0;
 PTHREAD_PRIO_INHERIT=1;
 PTHREAD_PRIO_PROTECT=2;

 PTHREAD_MUTEX_ERRORCHECK = 1; // Default POSIX mutex
 PTHREAD_MUTEX_RECURSIVE  = 2; // Recursive mutex
 PTHREAD_MUTEX_NORMAL     = 3; // No error checking
 PTHREAD_MUTEX_ADAPTIVE   = 4; // Adaptive mutex, spins briefly before blocking on lock
 PTHREAD_MUTEX_DEFAULT    = PTHREAD_MUTEX_ERRORCHECK;

implementation

end.


